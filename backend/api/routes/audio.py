"""Audio API routes."""

import logging
from datetime import datetime
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from fastapi.responses import StreamingResponse
import json

from backend.models.schemas import (
    AudioGenerateRequest,
    AudioGenerateResponse,
    AudioListResponse,
    AudioMetadata,
    ScriptGenerateRequest,
    ScriptGenerateResponse,
    VoiceOption,
    ErrorResponse
)
from backend.services.audio_service import AudioService, get_audio_service
from backend.services.elevenlabs_service import ElevenLabsTTSError
from backend.middleware.rate_limit import limiter, RATE_LIMITS

router = APIRouter(prefix="/api/audio", tags=["audio"])


@router.post(
    "/generate-script",
    response_model=ScriptGenerateResponse,
    responses={404: {"model": ErrorResponse}, 500: {"model": ErrorResponse}},
)
@limiter.limit(RATE_LIMITS["audio"])
async def generate_script(
    payload: ScriptGenerateRequest,
    request: Request,
    service: AudioService = Depends(get_audio_service)
):
    """Generate script from knowledge document."""
    try:
        result = await service.generate_script(
            knowledge_id=payload.knowledge_id,
            model_name=payload.model_name,
            custom_prompt=payload.custom_prompt,
            template_config=payload.template_config
        )
        return ScriptGenerateResponse(
            script=result["script"],
            knowledge_id=payload.knowledge_id,
            model_used=result["model_used"],
            generated_at=datetime.utcnow(),
            generation_error=result.get("generation_error"),
        )
    except ValueError as e:
        # Document not found
        raise HTTPException(status_code=404, detail=str(e))
    # Other exceptions bubble up to global handler


@router.post(
    "/generate-script-stream",
    response_class=StreamingResponse,
    responses={404: {"model": ErrorResponse}, 500: {"model": ErrorResponse}},
)
async def generate_script_stream(
    payload: ScriptGenerateRequest, service: AudioService = Depends(get_audio_service)
):
    """Stream script generation with Server-Sent Events.
    
    This endpoint streams tokens as they are generated by the LLM,
    keeping the connection alive and providing real-time feedback.
    This avoids timeout issues with large documents.
    
    Events are formatted as SSE:
    - data: {"type": "token", "content": "..."}
    - data: {"type": "complete", "script": "...", "model_used": "..."}
    - data: {"type": "error", "message": "..."}
    """
    async def event_generator():
        try:
            async for event in service.generate_script_stream(
                knowledge_id=payload.knowledge_id,
                model_name=payload.model_name,
                custom_prompt=payload.custom_prompt,
                template_config=payload.template_config
            ):
                # Format as Server-Sent Event
                yield f"data: {json.dumps(event)}\n\n"
        except Exception as e:
            error_event = {"type": "error", "message": str(e)}
            yield f"data: {json.dumps(error_event)}\n\n"
    
    return StreamingResponse(
        event_generator(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no",  # Disable nginx buffering
        }
    )


@router.post(
    "/generate",
    response_model=AudioGenerateResponse,
    responses={
        400: {"model": ErrorResponse},
        502: {"model": ErrorResponse},
        500: {"model": ErrorResponse},
    },
)
@limiter.limit(RATE_LIMITS["audio"])
async def generate_audio(
    payload: AudioGenerateRequest,
    request: Request,
    service: AudioService = Depends(get_audio_service)
):
    """Generate audio from script."""
    # Exceptions bubble up to global handler which maps ElevenLabs errors correctly
    metadata = await service.generate_audio(
        script=payload.script,
        voice_id=payload.voice_id,
        knowledge_id=payload.knowledge_id,
        doctor_id=payload.doctor_id,
    )
    return AudioGenerateResponse(
        audio_id=metadata.audio_id,
        audio_url=metadata.audio_url,
        knowledge_id=metadata.knowledge_id,
        voice_id=metadata.voice_id,
        duration_seconds=metadata.duration_seconds,
        script=metadata.script,
        created_at=metadata.created_at,
        doctor_id=metadata.doctor_id,
    )


@router.get(
    "/stream/{audio_id}",
    response_class=StreamingResponse,
    responses={404: {"model": ErrorResponse}, 500: {"model": ErrorResponse}},
)
async def stream_audio(
    audio_id: str, service: AudioService = Depends(get_audio_service)
):
    """Stream audio content."""
    try:
        return StreamingResponse(
            service.stream_audio(audio_id),
            media_type="audio/mpeg",
             headers={
                "Cache-Control": "public, max-age=3600",
                "Content-Disposition": f"inline; filename={audio_id}.mp3"
            }
        )
    except Exception as e:
        # If file not found or other storage error
        raise HTTPException(status_code=404, detail=f"Audio not found: {str(e)}")


@router.get(
    "/list",
    response_model=AudioListResponse,
    responses={500: {"model": ErrorResponse}},
)
async def list_audio_files(
    knowledge_id: Optional[str] = Query(None, description="Filter by knowledge document ID"),
    doctor_id: Optional[str] = Query(None, description="Filter by doctor ID"),
    service: AudioService = Depends(get_audio_service)
):
    """List audio files with optional filters.
    
    Supports filtering by knowledge_id and/or doctor_id.
    If both are provided, returns audio matching both criteria.
    """
    audio_files = await service.get_audio_files(knowledge_id=knowledge_id, doctor_id=doctor_id)
    return AudioListResponse(
        audio_files=audio_files,
        total_count=len(audio_files)
    )


@router.get(
    "/{knowledge_id}",
    response_model=AudioListResponse,
    responses={500: {"model": ErrorResponse}},
)
async def get_audio_files(
    knowledge_id: str, service: AudioService = Depends(get_audio_service)
):
    """Get audio files for a knowledge document (legacy endpoint)."""
    audio_files = await service.get_audio_files(knowledge_id=knowledge_id)
    return AudioListResponse(
        audio_files=audio_files,
        total_count=len(audio_files)
    )


@router.delete(
    "/{audio_id}",
    responses={404: {"model": ErrorResponse}, 500: {"model": ErrorResponse}},
)
async def delete_audio(
    audio_id: str, service: AudioService = Depends(get_audio_service)
):
    """Delete an audio file.
    
    Removes both the audio file from storage and its metadata from the database.
    """
    try:
        success = await service.delete_audio(audio_id)
        if not success:
            raise HTTPException(status_code=404, detail=f"Audio file {audio_id} not found")
        return {"success": True, "audio_id": audio_id}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to delete audio: {str(e)}")


@router.get(
    "/voices/list",
    response_model=List[VoiceOption],
    responses={502: {"model": ErrorResponse}, 500: {"model": ErrorResponse}},
)
async def get_available_voices(service: AudioService = Depends(get_audio_service)):
    """Get available voices."""
    return service.get_available_voices()
